> 进程：可以看作充分描述程序已经执行到何种程度的数据结构的汇集。从内核观点看，进程的目的就是担当分配系统资源(CPU时间、内存等)的实体.   

> 当一个进程创建时,先复制一份进程信息,分配CPU资源,在加入进程调度器。如果是新程序会替换进程执行地址空间。复制进程信息时并不完全拷贝父进程数据段、栈和堆，而是采用写时复制技术(copy On Wirte)。   

### 进程调度 - 进程调度的时机  
引起进程调度的原因以及进程调度的方式有关.   
>两种占用CPU的方式：     
可抢占式 preemptive：          就绪队列中一旦有优先级高于当前执行进程优先级的进程存在时，便立即发生进程调度，转让处理机。        
不可抢占式non_preemptive：        即使在就绪队列存在有优先级高与当前执行进程时，当前进程仍将占用处理机知道该进程自己因调用原语操作或等待I/O而进入阻塞、睡眠状态，或时间片用完时才重新发生调度让出处理机。   


#### 引起进程调度的原因有以下几类:
##### 一、在抢占式下
(1)正在执行的进程执行完毕。这时，如果不选择新的就绪进程执行，将浪费处理机资源。    
(2)执行中进程自己调用阻塞操作将白己阻塞起来进入睡眠等状态。    
(3)执行中进程调用了P原语操作，从而因资源不足而被阻塞；或调用了v原语操作激活了等待资源的进程队列。    
(4)执行中进程提出I/O请求后被阻塞。     
(5)在分时系统中时间片已经用完。    
(6)在执行完系统调用等系统程序后返回用户进程时，这时可看作系统进程执行完毕，从而可调度选择一新的用户进程执行。    
##### 二、 在不可抢占式
1)就绪队列中的某进程的优先级变得高于当前执行进程的优先级，从而也将引发进程调度。   


#### 进程调度的的分级(进程调度的方式) 
高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度：
高级调度 
(High-Level Scheduling)又称为作业调度，它决定把后备作业调入内存运行；
低级调度 
(Low-Level Scheduling)又称为进程调度，它决定把就绪队列的某进程获得CPU；
中级调度 
(Intermediate-Level Scheduling)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。


### 进程调度 - 进程调度算法

1.先进先出算法(FIFO)：按照进程进入就绪队列的先后次序来选择。   
2.时间片轮转算法(RR)：分时系统的一种调度算法。轮转的基本思想是，将CPU的处理时间划分成一个个的时间片，就绪队列中的进程轮流运行一个时间片。当时间片结束时，就强迫进程让出CPU，该进程进入就绪队列，等待下一次调度，同时，进程调度又去选择就绪队列中的一个进程，分配给它一个时间片，以投入运行。   
3.最高优先级算法(HPF)：进程调度每次将处理机分配给具有最高优先级的就绪进程。最高优先级算法可与不同的CPU方式结合形成可抢占式最高优先级算法和不可抢占式最高优先级算法。 
4. 多级队列反馈法：几种调度算法的结合形式多级队列方式。


#### 进程间通信（IPC）   
>为了进程间的通信，存在两个解决方法，共享内存，消息传递。  
在共享内存的方案里，为了几个进程间能够通信创建了一个共享的区域。这个区域能被多个进程同时访问。这种方法通常在使用线程时使用。这是实现IPC最快的形式，因为这种形式只涉及到内存的读写。 但是，这需要进程在访问共享内存时受到的限制和访问内核实现的其他进程内存一样。
共享内存段的使用情况可以使用ipcs -m命令查看。

#### 信号   
>介绍进程状态时，我们已经看了一个使用kill命令的信号示例。信号是把事件或者异常的发生通知进程的软件中断。   
每个信号都有一个整型标识，但通常使用 SIGXXX 来描述信号，例如 SIGSTOP 或者 SIGCONT 。内核使用信号来通知进程事件的发生，进程也可以使用kill()系统调用发送信号给进程。接收信号的进程可以忽略信号，被杀死，或者被挂起。可以使用信号处理器来处理信号并且在信号出现时任意处理信号。SIGKILL 这个特殊的信号不能被捕获（处理器处理）,要杀死一个挂起的进程时可以使用这个信号。不要把 SIGKILL 和 SIGTERM 混淆了，当使用 Ctrl+C 或者 kill <PID> 杀死进程时默认会发送 SIGKILL 信号。 SIGTERM 不会强制杀死进程并且它可以被捕获，使用 SIGTERM 的进程通常可以被清理。

#### 管道  
>管道用来把一个进程的输出连接到另外一个进程的输入。这是实现IPC最古老的方法之一。普通管道是单向通信的， 它有一个单向流。可以使用pipe() 创建一个管道，管道和Linux的其他对象一样，都被看成文件对象。
通其他文件一样，read()和write()操作都适用于管道。  
命名管道是普通管道的增强版，它是双向通信的并且可以实现管道的多进程读写。这都是普通管道不能实现的。无论有没有进程对命名管道进行读写，它都会实际存在。命名管道在文件系统里以特殊设备文件存在。在GNU/Linux里，命名管道也被称为FIFOs（先进先出，First In First Out）。
